-- Q3.hs — Student Academic Performance Report
-- Input lines like: Name:Mark   e.g., "Riya:77"
-- Classes: Fail<40, Pass 40–59, Merit 60–79, Distinction 80+
-- Requirements: pattern matching + guards + recursion; no external libs.

module Main where

import System.IO (stdin, hWaitForInput, hIsTerminalDevice, isEOF)

-- Simple string split (recursive)
split :: Char -> String -> [String]
split _ [] = [""]
split c (x:xs)
  | x == c    = "" : rest
  | otherwise = (x : head rest) : tail rest
  where
    rest = split c xs

type SM = (String, Int)

parseSM :: String -> SM
parseSM s =
  case split ':' s of
    [nm,m] -> (nm, read m)
    _      -> error "Bad line. Use Name:Mark"

category :: Int -> String
category m
  | m < 40    = "Fail"
  | m < 60    = "Pass"
  | m < 80    = "Merit"
  | otherwise = "Distinction"

-- Produce (Name,Mark,Category) recursively
annotate :: [SM] -> [(String, Int, String)]
annotate [] = []
annotate ((nm,m):xs) = (nm, m, category m) : annotate xs

-- Count passes (>=40) recursively
countPass :: [SM] -> Int
countPass [] = 0
countPass ((_,m):xs)
  | m >= 40   = 1 + countPass xs
  | otherwise = countPass xs

-- Interactive: read lines until empty line
getLinesInteractive :: IO [String]
getLinesInteractive = do
  ln <- getLine
  if null ln
    then return []
    else do rest <- getLinesInteractive
            return (ln : rest)

-- Non-interactive: slurp all lines until EOF (used when piped input exists)
getLinesNonInteractive :: IO [String]
getLinesNonInteractive = do
  eof <- isEOF
  if eof
    then return []
    else do ln <- getLine
            rest <- getLinesNonInteractive
            return (ln : rest)

-- Smart reader:
-- - If running in a real terminal: interactive (blank line to finish)
-- - If not a terminal:
--     * If no data is immediately available: return [] (exit cleanly)
--     * If data is available: read all until EOF
getLines :: IO [String]
getLines = do
  isTTY <- hIsTerminalDevice stdin
  if isTTY
     then getLinesInteractive
     else do
       avail <- hWaitForInput stdin 0   -- poll without blocking
       if not avail
          then return []                -- no stdin provided (avoid timeout)
          else getLinesNonInteractive

main :: IO ()
main = do
  putStrLn "Enter student marks (Name:Mark). Empty line to finish:"
  ls <- getLines
  if null ls
    then putStrLn "No input detected. Exiting without processing."
    else do
      let xs = map parseSM ls
          ys = annotate xs
          pc = countPass xs
      putStrLn "=== Performance ==="
      mapM_ (\(n,m,c) -> putStrLn (n ++ " " ++ show m ++ " -> " ++ c)) ys
      putStrLn ("Pass count (>=40): " ++ show pc)
