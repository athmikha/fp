-- Q1.hs â€” Hospital Patient Records Analysis
-- Input lines like: Name:Age:ReasonCode   e.g., "Alice:34:2"
-- Requirements: pattern matching + recursion; no external libs.

module Main where

import System.IO (stdin, hIsTerminalDevice, hWaitForInput, isEOF)

-- Split a string on a single character (recursive)
split :: Char -> String -> [String]
split _ [] = [""]
split c (x:xs)
  | x == c    = "" : rest
  | otherwise = (x : head rest) : tail rest
  where
    rest = split c xs

type Rec = (String, Int, Int) -- (Name, Age, ReasonCode)

parseRec :: String -> Rec
parseRec s =
  case split ':' s of
    [nm,a,r] -> (nm, read a, read r)
    _        -> error "Bad line. Use Name:Age:Reason"

-- Count reasons (1,2,3) recursively
countReasons :: [Rec] -> (Int, Int, Int)
countReasons [] = (0,0,0)
countReasons ((_,_,rc):xs)
  | rc == 1   = let (a,b,c) = countReasons xs in (a+1,b,c)
  | rc == 2   = let (a,b,c) = countReasons xs in (a,b+1,c)
  | rc == 3   = let (a,b,c) = countReasons xs in (a,b,c+1)
  | otherwise = countReasons xs

-- Count adults (age >= 18) recursively
countAdults :: [Rec] -> Int
countAdults [] = 0
countAdults ((_,age,_):xs)
  | age >= 18 = 1 + countAdults xs
  | otherwise = countAdults xs

-- Interactive: read lines until empty line
getLinesInteractive :: IO [String]
getLinesInteractive = do
  ln <- getLine
  if null ln
    then return []
    else do rest <- getLinesInteractive
            return (ln : rest)

-- Non-interactive: read all until EOF (for piped input)
getLinesNonInteractive :: IO [String]
getLinesNonInteractive = do
  eof <- isEOF
  if eof
    then return []
    else do ln <- getLine
            rest <- getLinesNonInteractive
            return (ln : rest)

-- Smart reader:
--  * If TTY: interactive (blank line to finish)
--  * If not TTY:
--      - if no data immediately: return [] (avoid blocking/timeout)
--      - else read all until EOF
getLines :: IO [String]
getLines = do
  isTTY <- hIsTerminalDevice stdin
  if isTTY
     then getLinesInteractive
     else do
       avail <- hWaitForInput stdin 0
       if not avail then return [] else getLinesNonInteractive

main :: IO ()
main = do
  putStrLn "Enter patient records (Name:Age:ReasonCode). Empty line to finish:"
  ls <- getLines
  if null ls
    then putStrLn "No input detected. Exiting without processing."
    else do
      let recs        = map parseRec ls
          (c1,c2,c3)  = countReasons recs
          adults      = countAdults recs
      putStrLn ("General Checkup (1): " ++ show c1)
      putStrLn ("Emergency (2): "       ++ show c2)
      putStrLn ("Surgery (3): "         ++ show c3)
      putStrLn ("Total adults (>=18): " ++ show adults)
